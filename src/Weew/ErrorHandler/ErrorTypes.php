<?php

namespace Weew\ErrorHandler;

use Weew\ErrorHandler\Errors\IError;
use Weew\ErrorHandler\Exceptions\CompileErrorException;
use Weew\ErrorHandler\Exceptions\CompileWarningException;
use Weew\ErrorHandler\Exceptions\CoreErrorException;
use Weew\ErrorHandler\Exceptions\CoreWarningException;
use Weew\ErrorHandler\Exceptions\DeprecatedException;
use Weew\ErrorHandler\Exceptions\ErrorException;
use Weew\ErrorHandler\Exceptions\MissingExceptionForErrorType;
use Weew\ErrorHandler\Exceptions\NoticeException;
use Weew\ErrorHandler\Exceptions\ParseException;
use Weew\ErrorHandler\Exceptions\RecoverableErrorException;
use Weew\ErrorHandler\Exceptions\StrictException;
use Weew\ErrorHandler\Exceptions\UserDeprecatedException;
use Weew\ErrorHandler\Exceptions\UserErrorException;
use Weew\ErrorHandler\Exceptions\UserNoticeException;
use Weew\ErrorHandler\Exceptions\UserWarningException;
use Weew\ErrorHandler\Exceptions\WarningException;

class ErrorTypes {
    /**
     * Fatal run-time errors. These indicate errors that can not be
     * recovered from, such as a memory allocation problem.
     * Execution of the script is halted.
     */
    const ERROR = E_ERROR;

    /**
     * Run-time warnings (non-fatal errors).
     * Execution of the script is not halted.
     */
    const WARNING = E_WARNING;

    /**
     * Compile-time parse errors. Parse errors should
     * only be generated by the parser.
     */
    const PARSE = E_PARSE;

    /**
     * Run-time notices. Indicate that the script encountered something
     * that could indicate an error, but could also happen in the normal
     * course of running a script.
     */
    const NOTICE = E_NOTICE;

    /**
     * Enable to have PHP suggest changes to your code which will
     * ensure the best interoperability and forward compatibility of your code.
     */
    const STRICT = E_STRICT;

    /**
     * Run-time notices. Enable this to receive warnings about code that
     * will not work in future versions.
     */
    const DEPRECATED = E_DEPRECATED;

    /**
     * Fatal errors that occur during PHP's initial startup.
     * This is like an E_ERROR, except it is generated by the core of PHP.
     */
    const CORE_ERROR = E_CORE_ERROR;

    /**
     * Warnings (non-fatal errors) that occur during PHP's initial startup.
     * This is like an E_WARNING, except it is generated by the core of PHP.
     */
    const CORE_WARNING = E_CORE_WARNING;

    /**
     * Fatal compile-time errors. This is like an E_ERROR, except
     * it is generated by the Zend Scripting Engine.
     */
    const COMPILE_ERROR = E_COMPILE_ERROR;

    /**
     * Compile-time warnings (non-fatal errors). This is like an E_WARNING,
     * except it is generated by the Zend Scripting Engine.
     */
    const COMPILE_WARNING = E_COMPILE_WARNING;

    /**
     * User-generated error message. This is like an E_ERROR, except it is
     * generated in PHP code by using the PHP function trigger_error().
     */
    const USER_ERROR = E_USER_ERROR;

    /**
     * User-generated warning message. This is like an E_WARNING, except it is
     * generated in PHP code by using the PHP function trigger_error().
     */
    const USER_WARNING = E_USER_WARNING;

    /**
     * User-generated notice message. This is like an E_NOTICE, except it is
     * generated in PHP code by using the PHP function trigger_error().
     */
    const USER_NOTICE = E_USER_NOTICE;

    /**
     * User-generated warning message. This is like an E_DEPRECATED, except
     * it is generated in PHP code by using the PHP function trigger_error().
     */
    const USER_DEPRECATED = E_USER_DEPRECATED;

    /**
     * Catchable fatal error. It indicates that a probably dangerous error
     * occurred, but did not leave the Engine in an unstable state.
     * If the error is not caught by a user defined handle
     * (see also set_error_handler()), the application aborts
     * as it was an E_ERROR.
     */
    const RECOVERABLE_ERROR = E_RECOVERABLE_ERROR;

    /**
     * @return array
     */
    public static function getRecoverableErrors() {
        return [
            self::WARNING, self::NOTICE, self::DEPRECATED,
            self::USER_ERROR, self::USER_WARNING, self::USER_NOTICE,
            self::USER_DEPRECATED, self::RECOVERABLE_ERROR,
        ];
    }

    /**
     * @return array
     */
    public static function getFatalErrors() {
        return [
            self::ERROR, self::PARSE, self::STRICT,
            self::CORE_ERROR, self::CORE_WARNING,
            self::COMPILE_ERROR, self::COMPILE_WARNING,
        ];
    }

    /**
     * @param $errorNumber
     *
     * @return bool
     */
    public static function isRecoverable($errorNumber) {
        return in_array($errorNumber, self::getRecoverableErrors());
    }

    /**
     * @param $errorNumber
     *
     * @return bool
     */
    public static function isFatal($errorNumber) {
        return in_array($errorNumber, self::getFatalErrors());
    }

    /**
     * @return array
     */
    public static function getErrorTypes() {
        return [
            self::ERROR => 'E_ERROR',
            self::WARNING => 'E_WARNING',
            self::PARSE => 'E_PARSE',
            self::NOTICE => 'E_NOTICE',
            self::CORE_ERROR => 'E_CORE_ERROR',
            self::CORE_WARNING => 'E_CORE_WARNING',
            self::COMPILE_ERROR => 'E_COMPILE_ERROR',
            self::COMPILE_WARNING => 'E_COMPILE_WARNING',
            self::USER_ERROR => 'E_USER_ERROR',
            self::USER_WARNING => 'E_USER_WARNING',
            self::USER_NOTICE => 'E_USER_NOTICE',
            self::STRICT => 'E_STRICT',
            self::RECOVERABLE_ERROR => 'E_RECOVERABLE_ERROR',
            self::DEPRECATED => 'E_DEPRECATED',
            self::USER_DEPRECATED => 'E_USER_DEPRECATED',
        ];
    }

    /**
     * @param $errorCode
     *
     * @return string
     */
    public static function getErrorTypeName($errorCode) {
        return array_get(self::getErrorTypes(), $errorCode);
    }

    /**
     * @param $errorName
     *
     * @return int
     */
    public static function getErrorTypeCode($errorName) {
        return array_get(array_flip(self::getErrorTypes()), $errorName);
    }

    /**
     * @return array
     */
    public static function getExceptionClassesForErrors() {
        return [
            self::ERROR => ErrorException::class,
            self::WARNING => WarningException::class,
            self::PARSE => ParseException::class,
            self::NOTICE => NoticeException::class,
            self::CORE_ERROR => CoreErrorException::class,
            self::CORE_WARNING => CoreWarningException::class,
            self::COMPILE_ERROR => CompileErrorException::class,
            self::COMPILE_WARNING => CompileWarningException::class,
            self::USER_ERROR => UserErrorException::class,
            self::USER_WARNING => UserWarningException::class,
            self::USER_NOTICE => UserNoticeException::class,
            self::STRICT => StrictException::class,
            self::RECOVERABLE_ERROR => RecoverableErrorException::class,
            self::DEPRECATED => DeprecatedException::class,
            self::USER_DEPRECATED => UserDeprecatedException::class,
        ];
    }

    /**
     * @param $errorNumber
     *
     * @return mixed
     * @throws MissingExceptionForErrorType
     */
    public static function getExceptionClassForError($errorNumber) {
        $class = array_get(self::getExceptionClassesForErrors(), $errorNumber);

        if ($class === null) {
            throw new MissingExceptionForErrorType(
                s('There is no custom exception for error of type "%s".', $errorNumber)
            );
        }

        return $class;
    }

    /**
     * @param IError $error
     *
     * @return mixed
     * @throws MissingExceptionForErrorType
     */
    public static function createExceptionForError(IError $error) {
        $class = static::getExceptionClassForError($error->getType());
        $ex = new $class(
            $error->getType(),
            $error->getMessage(),
            $error->getFile(),
            $error->getLine()
        );

        return $ex;
    }
}
